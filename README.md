# Brady Weber's ePortfolio for Full Stack Grocery Item Tracker

### Professional Self-Assessment

The coursework that I have completed during my time in this Computer Science program has provided me with a breadth of knowledge across multiple different facets of the Computer Science field. These courses have provided me with experiences in front-end, back-end, and full stack systems, as well as mobile application development, embedded systems development, machine learning and AI development, and exposed me to industry standard frameworks and practices such as developing with a security mindset, Agile development, reverse engineering, test-driven development, and utilizing a MEAN stack.
	In courses such as Software Development Lifecycle and System Analysis and Design, I learned how to develop software using Agile principles in a team environment and communicate design decisions with stakeholders and a non-technical audience. Throughout many of my courses, I utilized different data structure types to achieve success and develop solutions that provided value to the client. During my Operating Platforms class, I utilized design patterns such as the Singleton to implement industry-standard solutions. The Reverse Engineering class provided me an opportunity to learn more about utilizing core reverse engineering principles to develop a new viewpoint on designing software and recreating a secure architecture from a legacy codebase. In the Databases course and throughout other courses, I learned how to implement and utilize different databases, both relational and non-relational, such as MySQL, SQLite, and MongoDB. During the Software Security course, I learned about a plethora of different security measures to ensure that a system is defended against malicious actors; some of these measures include implementing authentication, authorization, accounting, parameterized queries and input validation to protect against SQL injection attacks, firewalls, cryptographic principles such as encryption and hash functions, and the principle of least privilege and zero trust security.
	In this Capstone course specifically, I was able to funnel many of these different concepts that I learned throughout my time in the Computer Science program into a single project. For the basis of this project, I chose a single, simple, MVP-style artifact to improve upon. I wanted to start with a basic project that would allow me to showcase my software engineering mindset of taking a minimum product and growing it into a deliverable solution while using industry-standard design principles and techniques. The original project, developed with C++, was designed to take a local file of a list of items and compile the data into an output file with a list of each item and its frequency from the original file. This was a simple I/O project that performed simple calculations on the data. In order to improve upon this project, I implemented a full-stack Python application that would read the data in from the same original file, store the data in an SQLite database, display that data in a simple and intuitive HTML front-end interface, and connect it all together using routes with Flask. The front-end interface allows for new items to be added to the list, manipulation of original item frequencies, and sorting the data by name or frequency via a selection sort algorithm. This data is then saved to the SQLite database in real time with each addition or manipulation. While there is no user access control implemented in the program, I still kept security in mind during development by implementing prepared statements on all SQL queries.


##[Orignal Project](https://github.com/Bweber0007/Bweber0007.github.io/tree/main/Original_Files)

##[Updated Project](https://github.com/Bweber0007/Bweber0007.github.io/tree/main/Updated_Files)

### Databases Narrative

The original artifact that I am using for all of these enhancements is a project from April 2024 that was originally developed to read a text file of grocery items purchased, track the frequency of purchases, and export the frequency data to a text file.
	The reason that I chose this artifact is that it provided a base project with ample room for improvement in the area of databases since the data was originally saved to a .txt file. In order to improve upon this original design I chose to implement an SQLite database to hold the data instead of exporting it to a local file. My implementation of the database includes multiple functions that facilitate the use of the database with the planned functionality of the application. These functions allow for the updated project to read a local file and save that data to the database. It also allows for the interface to manipulate the data and save the resulting information back to the database. These functions showcase my ability to develop basic CRUD functionality with a database. 
	The original course outcome that I planned to achieve in the databases section of this project was to develop a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources. I believe that I achieved this by utilizing SQLite’s built-in execute method which utilizes parameterized queries to ensure that the program is not vulnerable to SQL injection attacks. However, by using parameterized queries, I also believe that I achieved another course outcome: Demonstrate an ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals. Parameterized queries are a well-founded technique for delivering value in the form of industry standard security measures. 
	Due to previous coursework with databases, this project did not provide an abundance of new learning opportunities for me since the database structure was fairly simple in this project. However, one part of this project that allowed me to learn more was implementing the read from file structure with the intended functionality of the program. Since I wanted the database to be the main form of data storage and retrieval once the program was up and running, I needed to implement a way for the program to only read from the file initially if the database was empty. This provided me good practice if I ever needed to convert a legacy file system that is stored locally to a cloud database. Other than differentiating between file/database saves and utilizing parameterized queries, the rest of the project’s database programming was fairly simple CRUD implementation. 


### Software Engineering Narrative

  The original artifact that I am using for all of these enhancements is a project from April 2024 that was originally developed to read a text file of grocery items purchased, track the frequency of purchases, and export the frequency data to a text file.
  I selected this item because I wanted to work on a single project for all three of the improvement areas. I think that a single project makes more sense for the purpose of showcasing my abilities in an interview context rather than multiple smaller projects. During an interview I may not have time to discuss five different projects and how my work on them proves my capabilities so I figured that a single project would help me showcase my abilities in a more concise manner. Another reason that I chose this artifact was that it was a pretty simple project to begin with, and I wanted something that would allow me to really explore and expand upon the initial development. 
  As they relate to the Software Design and Engineering requirements, my changes involved converting the program from C++ to Python, creating a frontend web interface for interacting with the data, and embracing OOP principles by adding an Item class to increase the modularity and data abstraction in the program.
  In my original documentation, I stated that I wanted to achieve the following two course objectives: Demonstrate an ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals; Design, develop, and deliver professional-quality oral, written, and visual communications that are coherent, technically sound, and appropriately adapted to specific audiences and contexts. I believe that I have done a fair job at accomplishing the first by implementing well-founded and innovative techniques to deliver value. However, I haven’t done a great job at the second one. I believe that by improving my in-line comments in the program I can increase the level of my written communications in order to provide more value to other developers or interviewers who interact with the program.
  I would say that this section was probably the largest chunk of development work that I needed to implement in order to achieve the desired outcome. This was due to the fact that the program did not possess any user interface originally (other than a data output file if you can really consider that any type of frontend). So, I decided to use Flask in order to implement the frontend, which proved to be a useful and simple tool for achieving what I needed. Flask in combination with the HTML template that I used provided a small learning curve that required me to spend a fair amount of time learning the different implementations. However, by using my previous projects throughout my Computer Science journey as well as some internet resources, I was able to piece together what I needed in order to provide the necessary functionality. Furthermore, once I figured out the basic layout for the HTML and Flask, the actual business logic, design, and routing was fairly simple. Since the original program wasn’t extremely complex or large, converting it from C++ to Python was relatively simple. The same goes for creating the Item class that provided some data abstraction and an easier interface for manipulating the data. After I had my basic functionality covered, I added a feature to the web interface that I was curious about and ended up learning a little more about session management in the process. It was just a script within the HTML that allowed the page to stay in the same scroll position when the page was reloaded. Since the page was reloaded when the data was altered, I found it annoying to have to scroll back to the previous location if data was being altered on one of the bottom items. So, I did a little research into how not to have that happen; in the process I was pleasantly surprised to find myself learning more about session management and how to utilize it.


### Algorithms and Data Structures Narrative

The original artifact that I am using for all of these enhancements is a project from April 2024 that was originally developed to read a text file of grocery items purchased, track the frequency of purchases, and export the frequency data to a text file.
I selected this item because I wanted to work on a single project for all three of the improvement areas. I think that a single project makes more sense for the purpose of showcasing my abilities in an interview context rather than multiple smaller projects. During an interview I may not have time to discuss five different projects and how my work on them proves my capabilities so I figured that a single project would help me showcase my abilities in a more concise manner. Another reason that I chose this artifact was that it was a pretty simple project to begin with, and I wanted something that would allow me to really explore and expand upon the initial development. 
The specific components of this artifact that relate directly to the category of Algorithms and Data Structures are the two sorting algorithms that I implemented. The two algorithms are both selection sort algorithms that sort the data by frequency and by name. The selection sort algorithm has a time complexity of O(n^2) which makes it not viable for large lists, but due to the smaller list size of this application’s data, it should not have any issues. If a very large amount of items were being sorted and the client wanted better performance, a quick sort or merge sort algorithm could be implemented to increase the average time complexity. But, since the list size is relatively small, the simple implementation of the selection sort is sufficient. Also, I implemented an Item class that houses the data of each item while it is being manipulated outside of the database. So, in a maybe unconventional definition of a data structure, I used these objects to provide a more structured interface for interacting with the data that is stored on the program level.
I believe that the improvements made to this artifact fall in line with the course outcome that I originally identified as my goal to achieve: Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices (data structures and algorithms).
When I first was thinking about and designing my improvements to this artifact, I was originally planning on implementing a dictionary to store the data at the program level i.e. outside of the database. However, when I began implementing this, I realized that since I was already providing an abstraction through the item class itself to store the name and frequency of the item, a dictionary was not needed, and I instead just implemented a list of item objects. If I had used a dictionary, I would have been storing the data for each item in a dictionary and within each item object. This allowed for a simpler interaction between functions and data than trying to pull the data to a dictionary also. The implementation of the sorting algorithms also proved to be somewhat time consuming, but a little online research allowed me to solve any issues I had with implementing the algorithms. Other than these, I did not find too many challenges during development as it relates to algorithms and data structures.
